################################
# <方針>
# N ** 2を実行しても、250000回だから2重ループは大丈夫。
# 異なる2点を選ぶ。異なる2点のx座標が等しい場合、y座標が等しい場合、x座標, y座標が異なる場合を考える。x座標, y座標が共に等しい場合は、問題文より考える必要はない。
# 異なる2点を選んだ時に、x1座標, x2座標が等しい場合、(1, 0), (-1, 0)の移動の繰り返しが最小の魔法の通りである。よって、x座標が等しい場合が出た or 出ていない場合を判定して、+2すると良い。
# 異なる2点を選んだ時に、y1座標, y2座標が等しい場合、(0, 1), (0, -1)の移動の繰り返しが最小の魔法の通りである。よって、y座標が等しい場合が出た or 出ていない場合を判定して、+2すると良い。
# 異なる2点を選んだ時に、x座標, y座標が異なる場合、傾きを求める。傾きが等しい街どおしは、2つの魔法で完結するので、重複を除いた傾きを洗い出して、x2すると問題を解くことが可能になる。
# 傾きとは? : https://ja.wikipedia.org/wiki/%E5%82%BE%E3%81%8D_(%E6%95%B0%E5%AD%A6)
################################

# 標準入力を受け付ける。
N = int(input())

xy = []
for i in range(N):
    x, y = map(int, input().split())
    xy.append((x, y))

# x1座標, x2座標が等しい街があるかどうかを判定するためのフラグ。
vertical_flag = False
# y1座標, y2座標が等しい街があるかどうかを判定するためのフラグ。
beside_flag = False
# 重複を除いた、傾き情報
tilt_list = set()
for i in range(N):
    for j in range(i + 1, N):
        # 異なる2点を取得する。
        x1, y1 = xy[i]
        x2, y2 = xy[j]

        # x1座標, x2座標が等しい街があるかどうか確かめる。
        if x1 == x2:
            vertical_flag = True
            continue

        # y1座標, y2座標が等しい街があるかどうか確かめる。
        if y1 == y2:
            beside_flag = True
            continue

        # 傾きを求める。
        tilt = (y2 - y1) / (x2 - x1)

        # 傾きを格納する。自動的に重複削除される。
        tilt_list.add(tilt)

cnt = 0
if vertical_flag:
    cnt += 2
if beside_flag:
    cnt += 2

print(cnt + (len(tilt_list) * 2))
