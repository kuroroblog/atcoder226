################################
# <方針>
# N ** 2を実行しても、250000回だから2重ループは大丈夫。
# 異なる2点を選ぶ。
# 異なる2点のx1座標とx2座標が等しい場合、y1座標とy2座標が等しい場合、x1座標とx2座標, y1座標とy2座標が異なる場合を考える。
# ※ x1座標とx2座標, y1座標とy2座標が共に等しい場合は、問題文より考える必要はない。
# 異なる2点を選んだ時に、x1座標とx2座標が等しい場合、(0, 1) or (0, -1)の移動の繰り返しで片方の街に到着できる。よって、x1座標とx2座標が等しい場合が存在するのか判定して、存在する場合に+2すると良い。
# 異なる2点を選んだ時に、y1座標とy2座標が等しい場合、(1, 0) or (-1, 0)の移動の繰り返しで片方の街に到着できる。よって、y1座標とy2座標が等しい場合が存在するのか判定して、存在する場合に+2すると良い。
# 異なる2点を選んだ時に、x1座標とx2座標, y1座標とy2座標が異なる場合、傾きを求める。傾きが等しい街どおしは、2種類の魔法で完結するので、重複を除いた傾きを洗い出して、x2すると問題を解くことが可能になる。
# 傾きとは? : https://ja.wikipedia.org/wiki/%E5%82%BE%E3%81%8D_(%E6%95%B0%E5%AD%A6)
################################

# 標準入力を受け付ける。
N = int(input())

xy = []
for i in range(N):
    x, y = map(int, input().split())
    xy.append((x, y))

# x1座標とx2座標が等しい街があるかどうかを判定するためのフラグ。
vertical_flag = False
# y1座標とy2座標が等しい街があるかどうかを判定するためのフラグ。
beside_flag = False
# 重複を除いた、傾き情報
tilt_list = set()
for i in range(N):
    for j in range(i + 1, N):
        # 異なる2点を取得する。
        x1, y1 = xy[i]
        x2, y2 = xy[j]

        # x1座標とx2座標が等しい街であるかどうか確かめる。
        if x1 == x2:
            vertical_flag = True
            continue

        # y1座標とy2座標が等しい街であるかどうか確かめる。
        if y1 == y2:
            beside_flag = True
            continue

        # 傾きを求める。
        tilt = (y2 - y1) / (x2 - x1)

        # 傾きを格納する。自動的に重複削除される。
        tilt_list.add(tilt)

cnt = 0
if vertical_flag:
    cnt += 2
if beside_flag:
    cnt += 2

print(cnt + (len(tilt_list) * 2))
